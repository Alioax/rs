"""
Calculate and export Land Surface Temperature (LST) in Celsius for a selected Landsat 5 TM scene

This script:
1. Loads the scene ID from selected_scene.json (generated by load_landsat5_tm_band6.py)
2. Loads the corresponding Landsat 5 TM image
3. Calculates LST in Celsius using Band 6 (thermal infrared)
4. Creates and exports a colorized Celsius temperature map with colorbar
"""

import ee
import os
import json
import urllib.request
from pathlib import Path
from PIL import Image, ImageDraw, ImageFont
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np

# Clear terminal screen
os.system('cls' if os.name == 'nt' else 'clear')

# Initialize Google Earth Engine
try:
    ee.Initialize(project='surface-hydrology')
    print("Google Earth Engine initialized successfully.")
except Exception as e:
    print(f"Error initializing GEE: {e}")
    print("You may need to run: ee.Authenticate()")
    exit(1)

# Load scene information from JSON file
scene_info_file = os.path.join('..', 'data', 'selected_scene.json')
if not os.path.exists(scene_info_file):
    print(f"Error: {scene_info_file} not found.")
    print("Please run load_landsat5_tm_band6.py first to generate the scene selection.")
    exit(1)

with open(scene_info_file, 'r') as f:
    scene_info = json.load(f)

scene_id = scene_info['scene_id']
collection_id = scene_info['collection_id']
date_acquired = scene_info['date_acquired']
cloud_cover = scene_info['cloud_cover']

print("=" * 60)
print("LAND SURFACE TEMPERATURE (LST) - CELSIUS MAP")
print("=" * 60)
print(f"Scene ID: {scene_id}")
print(f"Date Acquired: {date_acquired}")
print(f"Cloud Cover: {cloud_cover}%")
print(f"Collection: {collection_id}")
print("=" * 60)
print()

# Load the specific image from the collection
# Filter by scene ID or system ID
image = (ee.ImageCollection(collection_id)
         .filter(ee.Filter.eq('LANDSAT_SCENE_ID', scene_id))
         .first())

# Verify the image exists
try:
    image_id = image.get('system:id').getInfo()
    print(f"Successfully loaded image: {image_id}")
except Exception as e:
    print(f"Error loading image: {e}")
    print("Trying alternative method...")
    # Alternative: try using system:id if available
    system_id = scene_info.get('system_id', '')
    if system_id and system_id != 'N/A':
        image = ee.Image(system_id)
        print(f"Loaded image using system ID: {system_id}")
    else:
        print("Could not load the image. Please check the scene ID.")
        exit(1)

print()

# Get image geometry and native projection for export
aoi = image.geometry()
# Get the native projection from the image (usually UTM for Landsat)
native_crs = image.select(0).projection().crs().getInfo()
print(f"Image native CRS: {native_crs}")
print()

# ===================================================================
# EXTRACT METADATA PARAMETERS
# ===================================================================
print("=" * 60)
print("EXTRACTING METADATA PARAMETERS")
print("=" * 60)

# Extract metadata parameters from image properties
print("Extracting metadata parameters...")
try:
    rad_mult_b6 = image.get('RADIANCE_MULT_BAND_6').getInfo()
    rad_add_b6 = image.get('RADIANCE_ADD_BAND_6').getInfo()
    k1_b6 = image.get('K1_CONSTANT_BAND_6').getInfo()
    k2_b6 = image.get('K2_CONSTANT_BAND_6').getInfo()
    
    print(f"RADIANCE_MULT_BAND_6: {rad_mult_b6}")
    print(f"RADIANCE_ADD_BAND_6: {rad_add_b6}")
    print(f"K1_CONSTANT_BAND_6: {k1_b6}")
    print(f"K2_CONSTANT_BAND_6: {k2_b6}")
    
except Exception as e:
    print(f"Error extracting metadata: {e}")
    print("Trying alternative property names...")
    # Try alternative property access
    try:
        props = image.getInfo()['properties']
        rad_mult_b6 = props.get('RADIANCE_MULT_BAND_6')
        rad_add_b6 = props.get('RADIANCE_ADD_BAND_6')
        k1_b6 = props.get('K1_CONSTANT_BAND_6')
        k2_b6 = props.get('K2_CONSTANT_BAND_6')
        
        if not all([rad_mult_b6, rad_add_b6, k1_b6, k2_b6]):
            raise ValueError("Required metadata properties not found")
        
        print(f"RADIANCE_MULT_BAND_6: {rad_mult_b6}")
        print(f"RADIANCE_ADD_BAND_6: {rad_add_b6}")
        print(f"K1_CONSTANT_BAND_6: {k1_b6}")
        print(f"K2_CONSTANT_BAND_6: {k2_b6}")
    except Exception as e2:
        print(f"Error: Could not extract required metadata properties: {e2}")
        print("LST calculation cannot proceed without metadata.")
        exit(1)

print()

# ===================================================================
# CALCULATE LAND SURFACE TEMPERATURE
# ===================================================================
print("=" * 60)
print("CALCULATING LAND SURFACE TEMPERATURE")
print("=" * 60)

# Select Band 6 (thermal infrared)
print("Selecting Band 6 (thermal infrared)...")
band6 = image.select('B6')
print("Band 6 selected (120m native resolution)")
print()

# Convert DN to Radiance
# Formula: L = RADIANCE_MULT_BAND_6 * B6 + RADIANCE_ADD_BAND_6
print("Converting DN to spectral radiance...")
radiance = band6.multiply(rad_mult_b6).add(rad_add_b6)

# Compute radiance statistics for verification
radiance_stats = radiance.reduceRegion(
    reducer=ee.Reducer.minMax(),
    geometry=aoi,
    scale=120,  # Band 6 native resolution
    maxPixels=1e9
).getInfo()

rad_min = radiance_stats.get('B6_min', 0)
rad_max = radiance_stats.get('B6_max', 0)
print(f"Radiance range: {rad_min:.4f} - {rad_max:.4f} W/(m²·sr·µm)")
print()

# Convert Radiance to Kelvin (with emissivity correction e=0.95)
# Formula: T_kelvin = K2 / ln((K1 * 0.95 / L) + 1)
print("Converting radiance to brightness temperature (Kelvin)...")
print("Using emissivity correction factor: e = 0.95")

# Create constants as images for calculation
k1_img = ee.Image.constant(k1_b6)
k2_img = ee.Image.constant(k2_b6)
emissivity = 0.95

# Calculate: T = K2 / ln((K1 * e / L) + 1)
kelvin_temp = k2_img.divide(
    k1_img.multiply(emissivity)
    .divide(radiance)
    .add(1)
    .log()
)

# Compute Kelvin temperature statistics
kelvin_temp = kelvin_temp.rename('temperature')
kelvin_stats = kelvin_temp.reduceRegion(
    reducer=ee.Reducer.percentile([2, 98]),
    geometry=aoi,
    scale=120,
    maxPixels=1e9
).getInfo()

kelvin_min = kelvin_stats.get('temperature_p2', 0)
kelvin_max = kelvin_stats.get('temperature_p98', 0)
print(f"Temperature range (Kelvin): {kelvin_min:.2f} - {kelvin_max:.2f} K")
print()

# Convert Kelvin to Celsius
# Formula: T_celsius = T_kelvin - 273.15
print("Converting Kelvin to Celsius...")
celsius_temp = kelvin_temp.subtract(273.15)

# Compute Celsius temperature statistics
celsius_temp = celsius_temp.rename('temperature')
celsius_stats = celsius_temp.reduceRegion(
    reducer=ee.Reducer.percentile([2, 98]),
    geometry=aoi,
    scale=120,
    maxPixels=1e9
).getInfo()

celsius_min = celsius_stats.get('temperature_p2', 0)
celsius_max = celsius_stats.get('temperature_p98', 0)
print(f"Temperature range (Celsius): {celsius_min:.2f} - {celsius_max:.2f} °C")
print()

# ===================================================================
# CREATE CELSIUS TEMPERATURE MAP
# ===================================================================
print("=" * 60)
print("CREATING CELSIUS TEMPERATURE MAP")
print("=" * 60)

# Resample to 30m for visualization
print("Resampling to 30m resolution for visualization...")
celsius_temp_30m = celsius_temp.resample('bilinear').reproject(
    crs=native_crs,
    scale=30
)

# Create colorized visualization
celsius_visualized = celsius_temp_30m.visualize(
    min=celsius_min,
    max=celsius_max,
    palette=['blue', 'cyan', 'yellow', 'orange', 'red']
)

print("Celsius temperature map created.")
print()

# ===================================================================
# DOWNLOAD FUNCTION
# ===================================================================
def download_image(image, filename, aoi, native_crs, scale=30, max_scale=120):
    """
    Download image with automatic scale adjustment if too large.
    Tries progressively larger scales until download succeeds.
    Uses native CRS to maintain proper aspect ratio (square pixels).
    """
    scales_to_try = [scale, scale * 2, scale * 4, max_scale]
    
    for current_scale in scales_to_try:
        try:
            print(f"Attempting download at {current_scale}m resolution...")
            # Use native CRS to maintain proper aspect ratio
            # For Landsat, native CRS is typically UTM which preserves square pixels
            download_url = image.getDownloadURL({
                'scale': current_scale,
                'crs': native_crs,  # Use native projection instead of EPSG:4326
                'region': aoi,
                'format': 'PNG'
            })
            
            print(f"Downloading to: {filename}")
            print("This may take a few minutes depending on the image size...")
            
            # Download the file
            urllib.request.urlretrieve(download_url, str(filename))
            
            file_size = os.path.getsize(filename) / (1024 * 1024)  # Size in MB
            print(f"✓ Image saved successfully: {filename}")
            print(f"  Resolution: {current_scale}m")
            print(f"  File size: {file_size:.2f} MB")
            return True
            
        except Exception as e:
            error_msg = str(e)
            if "must be less than or equal to" in error_msg:
                if current_scale < max_scale:
                    print(f"  Image too large at {current_scale}m, trying higher scale...")
                    continue
                else:
                    print(f"  Error: Image still too large even at {max_scale}m resolution.")
                    print(f"  Original error: {e}")
                    return False
            else:
                print(f"  Error: {e}")
                return False
    
    return False

# ===================================================================
# DOWNLOAD CELSIUS MAP
# ===================================================================
print("=" * 60)
print("DOWNLOADING CELSIUS TEMPERATURE MAP")
print("=" * 60)

# Create output directory if it doesn't exist (one level up from scripts)
output_dir = Path(os.path.join('..', 'output'))
output_dir.mkdir(exist_ok=True, parents=True)

# Download Celsius temperature map
celsius_filename = output_dir / f"LST_Celsius_{scene_id}.png"
print("Downloading Celsius temperature map...")
celsius_success = download_image(celsius_visualized, celsius_filename, aoi, native_crs, scale=30, max_scale=120)

if not celsius_success:
    print("Error: Could not download Celsius temperature map.")
    exit(1)

print()

# ===================================================================
# ADD COLORBAR TO CELSIUS MAP
# ===================================================================
print("=" * 60)
print("ADDING COLORBAR TO CELSIUS MAP")
print("=" * 60)

print("Adding colorbar to Celsius map...")
try:
    # Load the Celsius map image
    celsius_img = Image.open(celsius_filename)
    img_width, img_height = celsius_img.size
    
    # Get font for text size calculation
    try:
        font = ImageFont.truetype("arial.ttf", 14)
    except:
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 14)
        except:
            font = ImageFont.load_default()
    
    # Calculate maximum label text width
    num_labels = 5
    label_values = []
    max_text_width = 0
    for i in range(num_labels):
        t = i / (num_labels - 1)
        temp_value = celsius_min + (celsius_max - celsius_min) * (1 - t)
        label_values.append(temp_value)
        label_text = f"{temp_value:.1f}°C"
        # Create temporary draw to measure text
        temp_img = Image.new('RGB', (100, 100), 'white')
        temp_draw = ImageDraw.Draw(temp_img)
        bbox = temp_draw.textbbox((0, 0), label_text, font=font)
        text_width = bbox[2] - bbox[0]
        max_text_width = max(max_text_width, text_width)
    
    # Create colorbar dimensions
    colorbar_width = 40
    colorbar_height = img_height
    colorbar_padding = 20  # Space between map and colorbar
    label_spacing = 10  # Space between colorbar and labels
    label_width = max_text_width + 10  # Add padding for labels
    
    # Create colorbar image (wide enough for colorbar + labels)
    colorbar_img = Image.new('RGB', (colorbar_width + label_spacing + label_width, colorbar_height), 'white')
    draw = ImageDraw.Draw(colorbar_img)
    
    # Define color palette (matching the visualization: blue, cyan, yellow, orange, red)
    colors = [
        (0, 0, 255),    # Blue
        (0, 255, 255),  # Cyan
        (255, 255, 0),  # Yellow
        (255, 165, 0),  # Orange
        (255, 0, 0)     # Red
    ]
    
    # Draw colorbar gradient
    num_steps = colorbar_height
    for i in range(num_steps):
        # Interpolate between colors
        pos = i / (num_steps - 1)
        if pos <= 0.25:
            # Blue to Cyan
            t = pos / 0.25
            r = int(colors[0][0] * (1 - t) + colors[1][0] * t)
            g = int(colors[0][1] * (1 - t) + colors[1][1] * t)
            b = int(colors[0][2] * (1 - t) + colors[1][2] * t)
        elif pos <= 0.5:
            # Cyan to Yellow
            t = (pos - 0.25) / 0.25
            r = int(colors[1][0] * (1 - t) + colors[2][0] * t)
            g = int(colors[1][1] * (1 - t) + colors[2][1] * t)
            b = int(colors[1][2] * (1 - t) + colors[2][2] * t)
        elif pos <= 0.75:
            # Yellow to Orange
            t = (pos - 0.5) / 0.25
            r = int(colors[2][0] * (1 - t) + colors[3][0] * t)
            g = int(colors[2][1] * (1 - t) + colors[3][1] * t)
            b = int(colors[2][2] * (1 - t) + colors[3][2] * t)
        else:
            # Orange to Red
            t = (pos - 0.75) / 0.25
            r = int(colors[3][0] * (1 - t) + colors[4][0] * t)
            g = int(colors[3][1] * (1 - t) + colors[4][1] * t)
            b = int(colors[3][2] * (1 - t) + colors[4][2] * t)
        
        # Draw line
        draw.rectangle([0, i, colorbar_width, i + 1], fill=(r, g, b))
    
    # Draw labels
    for i, temp_val in enumerate(label_values):
        y_pos = int((i / (num_labels - 1)) * colorbar_height)
        label_text = f"{temp_val:.1f}°C"
        
        # Get text size for positioning
        bbox = draw.textbbox((0, 0), label_text, font=font)
        text_height = bbox[3] - bbox[1]
        
        # Draw text (ensure it's within bounds)
        text_x = colorbar_width + label_spacing
        text_y = y_pos - text_height // 2
        # Clamp text_y to ensure it's visible
        text_y = max(0, min(text_y, colorbar_height - text_height))
        draw.text((text_x, text_y), label_text, fill='black', font=font)
    
    # Combine map and colorbar
    combined_width = img_width + colorbar_padding + colorbar_width + label_spacing + label_width
    combined_height = img_height
    combined_img = Image.new('RGB', (combined_width, combined_height), 'white')
    
    # Paste map on the left
    combined_img.paste(celsius_img, (0, 0))
    
    # Paste colorbar on the right (aligned to top)
    combined_img.paste(colorbar_img, (img_width + colorbar_padding, 0))
    
    # Save combined image
    combined_img.save(celsius_filename)
    print(f"✓ Colorbar added to Celsius map: {celsius_filename}")
    
except Exception as e:
    print(f"Warning: Could not add colorbar to Celsius map: {e}")
    print("Original map saved without colorbar.")

print()

# ===================================================================
# CREATE HISTOGRAM
# ===================================================================
print("=" * 60)
print("CREATING CELSIUS TEMPERATURE HISTOGRAM")
print("=" * 60)

print("Extracting Celsius temperature values for histogram...")
try:
    # Sample temperature values from the image
    # Use a reasonable sample size to avoid memory issues
    sample_scale = 120  # Use native resolution for sampling
    sample_points = celsius_temp.sample(
        region=aoi,
        scale=sample_scale,
        numPixels=10000,  # Sample 10,000 pixels
        seed=42
    )
    
    # Get temperature values
    temp_values = sample_points.aggregate_array('temperature').getInfo()
    temp_values = np.array(temp_values)
    
    # Filter out any invalid values (NaN, None, etc.)
    temp_values = temp_values[~np.isnan(temp_values)]
    
    print(f"Sampled {len(temp_values)} temperature values")
    print(f"Temperature range in sample: {temp_values.min():.2f} - {temp_values.max():.2f} °C")
    print()
    
    # Set matplotlib parameters
    mpl.rcParams['figure.dpi'] = 800
    mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=["#FF5F05", "#13294B", "#009FD4", "#FCB316", "#006230", "#007E8E", "#5C0E41", "#7D3E13"])
    
    # Create histogram
    print("Creating histogram...")
    fig, ax = plt.subplots(figsize=(9, 5.4))
    
    # Create histogram with custom color and edges
    n, bins, patches = ax.hist(temp_values, bins=50, color='#0baedd', edgecolor='black', linewidth=0.5, alpha=0.7)
    
    # Remove top and right spines
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    
    # Set x-axis limits from 0 to 60
    ax.set_xlim(0, 60)
    
    # Set labels and title
    ax.set_xlabel('Temperature (°C)', fontsize=14, fontweight='bold')
    ax.set_ylabel('Frequency', fontsize=14, fontweight='bold')
    ax.set_title(f'Land Surface Temperature (LST) Distribution\nScene: {scene_id} | Date: {date_acquired}', 
                 fontsize=14, fontweight='bold', pad=20)
    
    # Add grid for better readability
    ax.grid(True, alpha=0.3, linestyle='--', linewidth=0.5)
    ax.set_axisbelow(True)
    
    # Add statistics text box (without frame)
    mean_temp = np.mean(temp_values)
    median_temp = np.median(temp_values)
    std_temp = np.std(temp_values)
    
    stats_text = f'Mean: {mean_temp:.2f} °C\nMedian: {median_temp:.2f} °C\nStd Dev: {std_temp:.2f} °C'
    ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, 
            fontsize=12, verticalalignment='top')
    
    # Save histogram
    histogram_filename = output_dir / f"LST_Celsius_Histogram_{scene_id}.png"
    plt.tight_layout()
    plt.savefig(histogram_filename, dpi=800, bbox_inches='tight')
    plt.close()
    
    print(f"✓ Histogram saved: {histogram_filename}")
    print(f"  Mean temperature: {mean_temp:.2f} °C")
    print(f"  Median temperature: {median_temp:.2f} °C")
    print(f"  Standard deviation: {std_temp:.2f} °C")
    
except Exception as e:
    print(f"Warning: Could not create histogram: {e}")
    import traceback
    traceback.print_exc()

print()

# ===================================================================
# FINAL SUMMARY
# ===================================================================
print("=" * 60)
print("LST CELSIUS MAP GENERATION COMPLETE")
print("=" * 60)
print("Temperature Statistics:")
print(f"  Kelvin: {kelvin_min:.2f} - {kelvin_max:.2f} K")
print(f"  Celsius: {celsius_min:.2f} - {celsius_max:.2f} °C")
print()
print("Generated Files:")
print(f"  ✓ LST Celsius map: {celsius_filename}")
if 'histogram_filename' in locals():
    print(f"  ✓ LST Celsius histogram: {histogram_filename}")
print(f"All files saved in: {output_dir.absolute()}")
print()

