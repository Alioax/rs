"""
Calculate Land Surface Temperature (LST) for a selected Landsat 5 TM scene

This script:
1. Loads the scene ID from selected_scene.json (generated by load_landsat5_tm_band6.py)
2. Loads the corresponding Landsat 5 TM image
3. Creates and exports RGB composite image
4. Prepares for LST calculation (to be implemented)
"""

import ee
import os
import json
import urllib.request
from pathlib import Path
from PIL import Image, ImageDraw, ImageFont

# Clear terminal screen
os.system('cls' if os.name == 'nt' else 'clear')

# Initialize Google Earth Engine
try:
    ee.Initialize(project='surface-hydrology')
    print("Google Earth Engine initialized successfully.")
except Exception as e:
    print(f"Error initializing GEE: {e}")
    print("You may need to run: ee.Authenticate()")
    exit(1)

# Load scene information from JSON file
scene_info_file = os.path.join('..', 'data', 'selected_scene.json')
if not os.path.exists(scene_info_file):
    print(f"Error: {scene_info_file} not found.")
    print("Please run load_landsat5_tm_band6.py first to generate the scene selection.")
    exit(1)

with open(scene_info_file, 'r') as f:
    scene_info = json.load(f)

scene_id = scene_info['scene_id']
collection_id = scene_info['collection_id']
date_acquired = scene_info['date_acquired']
cloud_cover = scene_info['cloud_cover']

print("=" * 60)
print("LAND SURFACE TEMPERATURE (LST) CALCULATION")
print("=" * 60)
print(f"Scene ID: {scene_id}")
print(f"Date Acquired: {date_acquired}")
print(f"Cloud Cover: {cloud_cover}%")
print(f"Collection: {collection_id}")
print("=" * 60)
print()

# Load the specific image from the collection
# Filter by scene ID or system ID
image = (ee.ImageCollection(collection_id)
         .filter(ee.Filter.eq('LANDSAT_SCENE_ID', scene_id))
         .first())

# Verify the image exists
try:
    image_id = image.get('system:id').getInfo()
    print(f"Successfully loaded image: {image_id}")
except Exception as e:
    print(f"Error loading image: {e}")
    print("Trying alternative method...")
    # Alternative: try using system:id if available
    system_id = scene_info.get('system_id', '')
    if system_id and system_id != 'N/A':
        image = ee.Image(system_id)
        print(f"Loaded image using system ID: {system_id}")
    else:
        print("Could not load the image. Please check the scene ID.")
        exit(1)

print()
print("Image loaded successfully. Ready for LST calculation.")
print()

# Create RGB composite
print("=" * 60)
print("CREATING RGB COMPOSITE")
print("=" * 60)

# For Landsat 5 TM:
# Band 1: Blue (0.45-0.52 µm)
# Band 2: Green (0.52-0.60 µm)
# Band 3: Red (0.63-0.69 µm)
# Band 4: Near Infrared (0.76-0.90 µm)

# True Color RGB: B3 (Red), B2 (Green), B1 (Blue)
# False Color (Vegetation): B4 (NIR), B3 (Red), B2 (Green)

# Select RGB bands for true color
rgb_bands = ['B3', 'B2', 'B1']  # Red, Green, Blue
rgb_image = image.select(rgb_bands)

# Get image geometry and native projection for export
aoi = image.geometry()
# Get the native projection from the image (usually UTM for Landsat)
native_crs = image.select(0).projection().crs().getInfo()
print(f"Image native CRS: {native_crs}")

# Compute percentiles for proper stretching
print("Computing statistics for RGB visualization...")
percentiles = rgb_image.select(rgb_bands).reduceRegion(
    reducer=ee.Reducer.percentile([2, 98]),
    geometry=aoi,
    scale=30,  # 30m resolution for visible bands
    maxPixels=1e9
).getInfo()

# Extract min and max values for each band
b3_min = percentiles.get('B3_p2', 0)
b3_max = percentiles.get('B3_p98', 255)
b2_min = percentiles.get('B2_p2', 0)
b2_max = percentiles.get('B2_p98', 255)
b1_min = percentiles.get('B1_p2', 0)
b1_max = percentiles.get('B1_p98', 255)

print(f"Band 3 (Red) range: {b3_min:.2f} - {b3_max:.2f}")
print(f"Band 2 (Green) range: {b2_min:.2f} - {b2_max:.2f}")
print(f"Band 1 (Blue) range: {b1_min:.2f} - {b1_max:.2f}")

# Apply linear stretch to 0-255 range for visualization
rgb_visualized = rgb_image.visualize(
    bands=rgb_bands,
    min=[b3_min, b2_min, b1_min],
    max=[b3_max, b2_max, b1_max],
    gamma=1.2  # Slight gamma correction for better visualization
)

print()
print("RGB composite created successfully.")
print()

# Download RGB image locally
print("=" * 60)
print("DOWNLOADING RGB IMAGE")
print("=" * 60)

# Create output directory if it doesn't exist (one level up from scripts)
output_dir = Path(os.path.join('..', 'output'))
output_dir.mkdir(exist_ok=True, parents=True)

# Create filename based on scene ID
rgb_filename = output_dir / f"RGB_{scene_id}.png"

def download_image(image, filename, aoi, native_crs, scale=30, max_scale=120):
    """
    Download image with automatic scale adjustment if too large.
    Tries progressively larger scales until download succeeds.
    Uses native CRS to maintain proper aspect ratio (square pixels).
    """
    scales_to_try = [scale, scale * 2, scale * 4, max_scale]
    
    for current_scale in scales_to_try:
        try:
            print(f"Attempting download at {current_scale}m resolution...")
            # Use native CRS to maintain proper aspect ratio
            # For Landsat, native CRS is typically UTM which preserves square pixels
            download_url = image.getDownloadURL({
                'scale': current_scale,
                'crs': native_crs,  # Use native projection instead of EPSG:4326
                'region': aoi,
                'format': 'PNG'
            })
            
            print(f"Downloading to: {filename}")
            print("This may take a few minutes depending on the image size...")
            
            # Download the file
            urllib.request.urlretrieve(download_url, str(filename))
            
            file_size = os.path.getsize(filename) / (1024 * 1024)  # Size in MB
            print(f"✓ Image saved successfully: {filename}")
            print(f"  Resolution: {current_scale}m")
            print(f"  File size: {file_size:.2f} MB")
            return True
            
        except Exception as e:
            error_msg = str(e)
            if "must be less than or equal to" in error_msg:
                if current_scale < max_scale:
                    print(f"  Image too large at {current_scale}m, trying higher scale...")
                    continue
                else:
                    print(f"  Error: Image still too large even at {max_scale}m resolution.")
                    print(f"  Original error: {e}")
                    return False
            else:
                print(f"  Error: {e}")
                return False
    
    return False

print("Getting download URL for RGB image...")
rgb_success = download_image(rgb_visualized, rgb_filename, aoi, native_crs, scale=30, max_scale=120)

if not rgb_success:
    rgb_filename = None

print()

# Also create a false color composite (optional, for vegetation analysis)
print("Creating false color composite (NIR-Red-Green) for vegetation analysis...")
false_color_bands = ['B4', 'B3', 'B2']  # NIR, Red, Green
false_color_image = image.select(false_color_bands)

# Compute percentiles for false color
false_color_percentiles = false_color_image.select(false_color_bands).reduceRegion(
    reducer=ee.Reducer.percentile([2, 98]),
    geometry=aoi,
    scale=30,
    maxPixels=1e9
).getInfo()

b4_min = false_color_percentiles.get('B4_p2', 0)
b4_max = false_color_percentiles.get('B4_p98', 255)

print(f"Band 4 (NIR) range: {b4_min:.2f} - {b4_max:.2f}")

false_color_visualized = false_color_image.visualize(
    bands=false_color_bands,
    min=[b4_min, b3_min, b2_min],
    max=[b4_max, b3_max, b2_max],
    gamma=1.2
)

# Download false color composite locally
print("Getting download URL for false color image...")
# Extract band numbers (remove 'B' prefix) and create filename
band_numbers = ''.join([b.replace('B', '') for b in false_color_bands])
false_color_filename = output_dir / f"FalseColor_{band_numbers}_{scene_id}.png"

false_color_success = download_image(false_color_visualized, false_color_filename, aoi, native_crs, scale=30, max_scale=120)

if not false_color_success:
    false_color_filename = None

print()
print("=" * 60)
print("RGB DOWNLOAD COMPLETE")
print("=" * 60)
if rgb_filename:
    print(f"✓ True color RGB: {rgb_filename}")
if false_color_filename:
    print(f"✓ False color RGB: {false_color_filename}")
print(f"All files saved in: {output_dir.absolute()}")
print()

# ===================================================================
# LAND SURFACE TEMPERATURE (LST) CALCULATION
# ===================================================================
print("=" * 60)
print("LAND SURFACE TEMPERATURE (LST) CALCULATION")
print("=" * 60)

# Extract metadata parameters from image properties
print("Extracting metadata parameters...")
try:
    rad_mult_b6 = image.get('RADIANCE_MULT_BAND_6').getInfo()
    rad_add_b6 = image.get('RADIANCE_ADD_BAND_6').getInfo()
    k1_b6 = image.get('K1_CONSTANT_BAND_6').getInfo()
    k2_b6 = image.get('K2_CONSTANT_BAND_6').getInfo()
    
    print(f"RADIANCE_MULT_BAND_6: {rad_mult_b6}")
    print(f"RADIANCE_ADD_BAND_6: {rad_add_b6}")
    print(f"K1_CONSTANT_BAND_6: {k1_b6}")
    print(f"K2_CONSTANT_BAND_6: {k2_b6}")
    
except Exception as e:
    print(f"Error extracting metadata: {e}")
    print("Trying alternative property names...")
    # Try alternative property access
    try:
        props = image.getInfo()['properties']
        rad_mult_b6 = props.get('RADIANCE_MULT_BAND_6')
        rad_add_b6 = props.get('RADIANCE_ADD_BAND_6')
        k1_b6 = props.get('K1_CONSTANT_BAND_6')
        k2_b6 = props.get('K2_CONSTANT_BAND_6')
        
        if not all([rad_mult_b6, rad_add_b6, k1_b6, k2_b6]):
            raise ValueError("Required metadata properties not found")
        
        print(f"RADIANCE_MULT_BAND_6: {rad_mult_b6}")
        print(f"RADIANCE_ADD_BAND_6: {rad_add_b6}")
        print(f"K1_CONSTANT_BAND_6: {k1_b6}")
        print(f"K2_CONSTANT_BAND_6: {k2_b6}")
    except Exception as e2:
        print(f"Error: Could not extract required metadata properties: {e2}")
        print("LST calculation cannot proceed without metadata.")
        exit(1)

print()

# Select Band 6 (thermal infrared)
print("Selecting Band 6 (thermal infrared)...")
band6 = image.select('B6')
print("Band 6 selected (120m native resolution)")

# Convert DN to Radiance
# Formula: L = RADIANCE_MULT_BAND_6 * B6 + RADIANCE_ADD_BAND_6
print("Converting DN to spectral radiance...")
radiance = band6.multiply(rad_mult_b6).add(rad_add_b6)

# Compute radiance statistics for verification
radiance_stats = radiance.reduceRegion(
    reducer=ee.Reducer.minMax(),
    geometry=aoi,
    scale=120,  # Band 6 native resolution
    maxPixels=1e9
).getInfo()

rad_min = radiance_stats.get('B6_min', 0)
rad_max = radiance_stats.get('B6_max', 0)
print(f"Radiance range: {rad_min:.4f} - {rad_max:.4f} W/(m²·sr·µm)")
print()

# Convert Radiance to Kelvin (with emissivity correction e=0.95)
# Formula: T_kelvin = K2 / ln((K1 * 0.95 / L) + 1)
print("Converting radiance to brightness temperature (Kelvin)...")
print("Using emissivity correction factor: e = 0.95")

# Create constants as images for calculation
k1_img = ee.Image.constant(k1_b6)
k2_img = ee.Image.constant(k2_b6)
emissivity = 0.95

# Calculate: T = K2 / ln((K1 * e / L) + 1)
kelvin_temp = k2_img.divide(
    k1_img.multiply(emissivity)
    .divide(radiance)
    .add(1)
    .log()
)

# Compute Kelvin temperature statistics
# Rename band to 'temperature' for easier access
kelvin_temp = kelvin_temp.rename('temperature')
kelvin_stats = kelvin_temp.reduceRegion(
    reducer=ee.Reducer.percentile([2, 98]),
    geometry=aoi,
    scale=120,
    maxPixels=1e9
).getInfo()

kelvin_min = kelvin_stats.get('temperature_p2', 0)
kelvin_max = kelvin_stats.get('temperature_p98', 0)
print(f"Temperature range (Kelvin): {kelvin_min:.2f} - {kelvin_max:.2f} K")
print()

# Convert Kelvin to Celsius
# Formula: T_celsius = T_kelvin - 273.15
print("Converting Kelvin to Celsius...")
celsius_temp = kelvin_temp.subtract(273.15)

# Compute Celsius temperature statistics
# Rename band to 'temperature' for easier access
celsius_temp = celsius_temp.rename('temperature')
celsius_stats = celsius_temp.reduceRegion(
    reducer=ee.Reducer.percentile([2, 98]),
    geometry=aoi,
    scale=120,
    maxPixels=1e9
).getInfo()

celsius_min = celsius_stats.get('temperature_p2', 0)
celsius_max = celsius_stats.get('temperature_p98', 0)
print(f"Temperature range (Celsius): {celsius_min:.2f} - {celsius_max:.2f} °C")
print()

# ===================================================================
# CREATE TEMPERATURE MAPS
# ===================================================================
print("=" * 60)
print("CREATING TEMPERATURE MAPS")
print("=" * 60)

# 1. Grayscale B6 Band Map
print("Creating grayscale B6 band map...")
b6_stats = band6.reduceRegion(
    reducer=ee.Reducer.percentile([2, 98]),
    geometry=aoi,
    scale=120,
    maxPixels=1e9
).getInfo()

b6_min = b6_stats.get('B6_p2', 0)
b6_max = b6_stats.get('B6_p98', 255)

print(f"B6 DN range: {b6_min:.0f} - {b6_max:.0f}")

# Resample B6 to 30m for consistency with other outputs
band6_30m = band6.resample('bilinear').reproject(
    crs=native_crs,
    scale=30
)

b6_visualized = band6_30m.visualize(
    min=b6_min,
    max=b6_max,
    palette=['black', 'white']
)

print("Grayscale B6 map created.")
print()

# 2. Kelvin Temperature Map (Colorized)
print("Creating colorized Kelvin temperature map...")
# Resample to 30m for visualization
kelvin_temp_30m = kelvin_temp.resample('bilinear').reproject(
    crs=native_crs,
    scale=30
)

kelvin_visualized = kelvin_temp_30m.visualize(
    min=kelvin_min,
    max=kelvin_max,
    palette=['blue', 'cyan', 'yellow', 'orange', 'red']
)

print("Kelvin temperature map created.")
print()

# 3. Celsius Temperature Map (Colorized)
print("Creating colorized Celsius temperature map...")
# Resample to 30m for visualization
celsius_temp_30m = celsius_temp.resample('bilinear').reproject(
    crs=native_crs,
    scale=30
)

celsius_visualized = celsius_temp_30m.visualize(
    min=celsius_min,
    max=celsius_max,
    palette=['blue', 'cyan', 'yellow', 'orange', 'red']
)

print("Celsius temperature map created.")
print()

# ===================================================================
# DOWNLOAD TEMPERATURE MAPS
# ===================================================================
print("=" * 60)
print("DOWNLOADING TEMPERATURE MAPS")
print("=" * 60)

# Download grayscale B6 map
b6_filename = output_dir / f"B6_Grayscale_{scene_id}.png"
print("Downloading grayscale B6 map...")
b6_success = download_image(b6_visualized, b6_filename, aoi, native_crs, scale=30, max_scale=120)
if not b6_success:
    b6_filename = None

print()

# Download Kelvin temperature map
kelvin_filename = output_dir / f"LST_Kelvin_{scene_id}.png"
print("Downloading Kelvin temperature map...")
kelvin_success = download_image(kelvin_visualized, kelvin_filename, aoi, native_crs, scale=30, max_scale=120)
if not kelvin_success:
    kelvin_filename = None

print()

# Download Celsius temperature map
celsius_filename = output_dir / f"LST_Celsius_{scene_id}.png"
print("Downloading Celsius temperature map...")
celsius_success = download_image(celsius_visualized, celsius_filename, aoi, native_crs, scale=30, max_scale=120)
if not celsius_success:
    celsius_filename = None
else:
    # Add colorbar to Celsius map
    print("Adding colorbar to Celsius map...")
    try:
        # Load the Celsius map image
        celsius_img = Image.open(celsius_filename)
        img_width, img_height = celsius_img.size
        
        # Get font for text size calculation
        try:
            font = ImageFont.truetype("arial.ttf", 14)
        except:
            try:
                font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 14)
            except:
                font = ImageFont.load_default()
        
        # Calculate maximum label text width
        num_labels = 5
        label_values = []
        max_text_width = 0
        for i in range(num_labels):
            t = i / (num_labels - 1)
            temp_value = celsius_min + (celsius_max - celsius_min) * (1 - t)
            label_values.append(temp_value)
            label_text = f"{temp_value:.1f}°C"
            # Create temporary draw to measure text
            temp_img = Image.new('RGB', (100, 100), 'white')
            temp_draw = ImageDraw.Draw(temp_img)
            bbox = temp_draw.textbbox((0, 0), label_text, font=font)
            text_width = bbox[2] - bbox[0]
            max_text_width = max(max_text_width, text_width)
        
        # Create colorbar dimensions
        colorbar_width = 40
        colorbar_height = img_height
        colorbar_padding = 20  # Space between map and colorbar
        label_spacing = 10  # Space between colorbar and labels
        label_width = max_text_width + 10  # Add padding for labels
        
        # Create colorbar image (wide enough for colorbar + labels)
        colorbar_img = Image.new('RGB', (colorbar_width + label_spacing + label_width, colorbar_height), 'white')
        draw = ImageDraw.Draw(colorbar_img)
        
        # Define color palette (matching the visualization: blue, cyan, yellow, orange, red)
        colors = [
            (0, 0, 255),    # Blue
            (0, 255, 255),  # Cyan
            (255, 255, 0),  # Yellow
            (255, 165, 0),  # Orange
            (255, 0, 0)     # Red
        ]
        
        # Draw colorbar gradient
        num_steps = colorbar_height
        for i in range(num_steps):
            # Interpolate between colors
            pos = i / (num_steps - 1)
            if pos <= 0.25:
                # Blue to Cyan
                t = pos / 0.25
                r = int(colors[0][0] * (1 - t) + colors[1][0] * t)
                g = int(colors[0][1] * (1 - t) + colors[1][1] * t)
                b = int(colors[0][2] * (1 - t) + colors[1][2] * t)
            elif pos <= 0.5:
                # Cyan to Yellow
                t = (pos - 0.25) / 0.25
                r = int(colors[1][0] * (1 - t) + colors[2][0] * t)
                g = int(colors[1][1] * (1 - t) + colors[2][1] * t)
                b = int(colors[1][2] * (1 - t) + colors[2][2] * t)
            elif pos <= 0.75:
                # Yellow to Orange
                t = (pos - 0.5) / 0.25
                r = int(colors[2][0] * (1 - t) + colors[3][0] * t)
                g = int(colors[2][1] * (1 - t) + colors[3][1] * t)
                b = int(colors[2][2] * (1 - t) + colors[3][2] * t)
            else:
                # Orange to Red
                t = (pos - 0.75) / 0.25
                r = int(colors[3][0] * (1 - t) + colors[4][0] * t)
                g = int(colors[3][1] * (1 - t) + colors[4][1] * t)
                b = int(colors[3][2] * (1 - t) + colors[4][2] * t)
            
            # Draw line
            draw.rectangle([0, i, colorbar_width, i + 1], fill=(r, g, b))
        
        # Draw labels
        for i, temp_val in enumerate(label_values):
            y_pos = int((i / (num_labels - 1)) * colorbar_height)
            label_text = f"{temp_val:.1f}°C"
            
            # Get text size for positioning
            bbox = draw.textbbox((0, 0), label_text, font=font)
            text_height = bbox[3] - bbox[1]
            
            # Draw text (ensure it's within bounds)
            text_x = colorbar_width + label_spacing
            text_y = y_pos - text_height // 2
            # Clamp text_y to ensure it's visible
            text_y = max(0, min(text_y, colorbar_height - text_height))
            draw.text((text_x, text_y), label_text, fill='black', font=font)
        
        # Combine map and colorbar
        combined_width = img_width + colorbar_padding + colorbar_width + label_spacing + label_width
        combined_height = img_height
        combined_img = Image.new('RGB', (combined_width, combined_height), 'white')
        
        # Paste map on the left
        combined_img.paste(celsius_img, (0, 0))
        
        # Paste colorbar on the right (aligned to top)
        combined_img.paste(colorbar_img, (img_width + colorbar_padding, 0))
        
        # Save combined image
        combined_img.save(celsius_filename)
        print(f"✓ Colorbar added to Celsius map: {celsius_filename}")
        
    except Exception as e:
        print(f"Warning: Could not add colorbar to Celsius map: {e}")
        print("Original map saved without colorbar.")

print()

# ===================================================================
# FINAL SUMMARY
# ===================================================================
print("=" * 60)
print("LST CALCULATION COMPLETE")
print("=" * 60)
print("Temperature Statistics:")
print(f"  Kelvin: {kelvin_min:.2f} - {kelvin_max:.2f} K")
print(f"  Celsius: {celsius_min:.2f} - {celsius_max:.2f} °C")
print()
print("Downloaded Files:")
if rgb_filename:
    print(f"  ✓ True color RGB: {rgb_filename}")
if false_color_filename:
    print(f"  ✓ False color RGB: {false_color_filename}")
if b6_filename:
    print(f"  ✓ B6 Grayscale: {b6_filename}")
if kelvin_filename:
    print(f"  ✓ LST Kelvin: {kelvin_filename}")
if celsius_filename:
    print(f"  ✓ LST Celsius: {celsius_filename}")
print(f"All files saved in: {output_dir.absolute()}")
print()

